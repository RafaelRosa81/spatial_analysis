diff --git a/README.md b/README.md
index 932428bb5f8e650cdf81f9c38e673b9f3372083d..444d55842e5bf5b60f749b261502f8123234d6f1 100644
--- a/README.md
+++ b/README.md
@@ -47,25 +47,72 @@ python scripts/compare_rasters.py \
   --resampling bilinear
 ```
 
 The signed dz raster is computed as raster2 - raster1 (positive means raster2 is higher), and
 abs_dz is the magnitude of the difference.
 
 QGIS Integration
 
 
 ```bash
 python -m scripts.compare_rasters --raster1 "path/to/dem1.tif" --raster2 "path/to/dem2.tif" --outdir outputs/test --name test --excel
 
 ```
 
 Load the dz and abs_dz rasters in QGIS, then apply styles via Layer Properties → Symbology → Style → Load Style… and select the QML files copied into the output folder (outdir/qgis).
 
 If you enable the exceedance vector output, add the GeoJSON layer from outdir/vectors for a polygon overlay of |dz| > threshold.
 
 
 
 ---
 
 # 4) Verificación inmediata (antes de commit)
 ```bat
 python -m scripts.compare_rasters --help
+```
+
+## Quickstart
+
+CLI example:
+
+```bash
+python scripts/compare_rasters.py \
+  --raster1 data/dem_2020.tif \
+  --raster2 data/dem_2022.tif \
+  --outdir outputs \
+  --name demo_run \
+  --resampling bilinear \
+  --excel \
+  --qgis-assets \
+  --vector-threshold 0.5
+```
+
+Config-based example:
+
+```bash
+python scripts/run_from_config.py --config config/example_config.yml
+```
+
+## Outputs
+
+The workflow creates the following folders and files under the output directory:
+
+- `aligned/`: aligned inputs (`*_raster1_aligned.tif`, `*_raster2_aligned.tif`)
+- `rasters/`: difference rasters (`*_dz.tif`, `*_abs_dz.tif`)
+- `report/`: Excel report (`*_Comparison_Report.xlsx`) when `excel: true`
+- `vectors/`: exceedance polygons (`*_abs_dz_gt_<threshold>.geojson`) when `vector_threshold` is set
+- `qgis/`: QML styles copied when `qgis_assets: true`
+
+## QGIS recommended layer order
+
+1. hillshade (optional) bottom
+2. raster1 (optional)
+3. dz (with dz style)
+4. abs_dz (optional)
+5. exceedance polygons (top)
+
+## Notes / pitfalls
+
+- Ensure rasters are comparable (same vertical datum/units).
+- Resampling choice matters: use `nearest` for categorical inputs, `bilinear` for continuous surfaces.
+- If the CRS is geographic (degrees), polygon areas are in degrees².
diff --git a/config/example_config.yml b/config/example_config.yml
new file mode 100644
index 0000000000000000000000000000000000000000..54f29980ff1477e6ed670ad87732fb290a661454
--- /dev/null
+++ b/config/example_config.yml
@@ -0,0 +1,10 @@
+raster1: "path/to/raster1.tif"
+raster2: "path/to/raster2.tif"
+outdir: "outputs"
+name: "demo_run"
+resampling: "bilinear"
+excel: true
+thresholds: [0.10, 0.25, 0.50, 1.00]
+bins: 60
+qgis_assets: true
+vector_threshold: 0.5
diff --git a/scripts/run_from_config.py b/scripts/run_from_config.py
new file mode 100644
index 0000000000000000000000000000000000000000..28847f72f819f8b1833028c91a8d6913b6ad479e
--- /dev/null
+++ b/scripts/run_from_config.py
@@ -0,0 +1,168 @@
+from __future__ import annotations
+
+import argparse
+from pathlib import Path
+from pprint import pformat
+
+import yaml
+
+from raster_compare.core import align_to_reference, compute_dz
+from raster_compare.qgis import copy_qgis_assets, polygonize_exceedance
+from raster_compare.report import write_excel_report
+
+
+ALLOWED_RESAMPLING = {"nearest", "bilinear", "cubic"}
+REQUIRED_KEYS = {
+    "raster1",
+    "raster2",
+    "outdir",
+    "name",
+    "resampling",
+    "excel",
+    "thresholds",
+    "bins",
+    "qgis_assets",
+    "vector_threshold",
+}
+
+
+def parse_args() -> argparse.Namespace:
+    parser = argparse.ArgumentParser(
+        description="Run raster comparison workflow from a YAML config."
+    )
+    parser.add_argument("--config", required=True, help="Path to YAML config file")
+    return parser.parse_args()
+
+
+def load_config(config_path: Path) -> dict:
+    with config_path.open("r", encoding="utf-8") as handle:
+        config = yaml.safe_load(handle) or {}
+
+    missing = REQUIRED_KEYS - set(config)
+    if missing:
+        missing_list = ", ".join(sorted(missing))
+        raise ValueError(f"Config missing required keys: {missing_list}")
+
+    resampling = str(config["resampling"]).lower()
+    if resampling not in ALLOWED_RESAMPLING:
+        allowed = ", ".join(sorted(ALLOWED_RESAMPLING))
+        raise ValueError(f"resampling must be one of: {allowed}")
+
+    config["resampling"] = resampling
+    return config
+
+
+def main() -> None:
+    args = parse_args()
+    config_path = Path(args.config)
+    config = load_config(config_path)
+
+    raster1 = Path(config["raster1"]).expanduser().resolve()
+    raster2 = Path(config["raster2"]).expanduser().resolve()
+    outdir = Path(config["outdir"]).expanduser().resolve()
+    name = str(config["name"])
+    resampling = config["resampling"]
+    excel = bool(config["excel"])
+    thresholds = list(map(float, config["thresholds"]))
+    bins = int(config["bins"])
+    qgis_assets = bool(config["qgis_assets"])
+    vector_threshold = config["vector_threshold"]
+
+    if vector_threshold is not None:
+        vector_threshold = float(vector_threshold)
+
+    resolved_config = {
+        "raster1": str(raster1),
+        "raster2": str(raster2),
+        "outdir": str(outdir),
+        "name": name,
+        "resampling": resampling,
+        "excel": excel,
+        "thresholds": thresholds,
+        "bins": bins,
+        "qgis_assets": qgis_assets,
+        "vector_threshold": vector_threshold,
+    }
+
+    print("Resolved configuration:")
+    print(pformat(resolved_config))
+
+    aligned_dir = outdir / "aligned"
+    rasters_dir = outdir / "rasters"
+    report_dir = outdir / "report"
+
+    aligned_dir.mkdir(parents=True, exist_ok=True)
+    rasters_dir.mkdir(parents=True, exist_ok=True)
+
+    raster1_aligned = aligned_dir / f"{name}_raster1_aligned.tif"
+    raster2_aligned = aligned_dir / f"{name}_raster2_aligned.tif"
+
+    align_to_reference(
+        src_path=raster1,
+        ref_path=raster1,
+        out_path=raster1_aligned,
+        resampling="nearest",
+        overwrite=False,
+    )
+    align_to_reference(
+        src_path=raster2,
+        ref_path=raster1,
+        out_path=raster2_aligned,
+        resampling=resampling,
+        overwrite=False,
+    )
+
+    dz_path = rasters_dir / f"{name}_dz.tif"
+    abs_dz_path = rasters_dir / f"{name}_abs_dz.tif"
+    compute_dz(
+        raster1_aligned=raster1_aligned,
+        raster2_aligned=raster2_aligned,
+        out_dz=dz_path,
+        out_abs_dz=abs_dz_path,
+        overwrite=False,
+    )
+
+    qgis_dir = None
+    vector_path = None
+    if qgis_assets:
+        qgis_dir = copy_qgis_assets(outdir)
+    if vector_threshold is not None:
+        vectors_dir = outdir / "vectors"
+        threshold_str = f"{vector_threshold:g}"
+        vector_path = vectors_dir / f"{name}_abs_dz_gt_{threshold_str}.geojson"
+        polygonize_exceedance(
+            abs_dz_path=abs_dz_path,
+            out_vector_path=vector_path,
+            threshold=vector_threshold,
+            overwrite=False,
+        )
+
+    excel_path = None
+    if excel:
+        report_dir.mkdir(parents=True, exist_ok=True)
+        excel_path = report_dir / f"{name}_Comparison_Report.xlsx"
+        write_excel_report(
+            dz_path=dz_path,
+            abs_dz_path=abs_dz_path,
+            raster1_path=raster1_aligned,
+            raster2_path=raster2_aligned,
+            out_xlsx=excel_path,
+            thresholds=thresholds,
+            bins=bins,
+        )
+
+    print("Generated outputs:")
+    print(f"- {raster1_aligned}")
+    print(f"- {raster2_aligned}")
+    print(f"- {dz_path}")
+    print(f"- {abs_dz_path}")
+    if qgis_dir is not None:
+        print(f"- {qgis_dir}")
+    if vector_path is not None:
+        print(f"- {vector_path}")
+    if excel_path is not None:
+        print(f"- {excel_path}")
+
+
+if __name__ == "__main__":
+    main()
